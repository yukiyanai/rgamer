% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/matching.R
\name{matching}
\alias{matching}
\title{Implement matching}
\usage{
matching(
  g1_prefs,
  g2_prefs,
  g1_names = NULL,
  g2_names = NULL,
  algorithm = "DA",
  switch = FALSE,
  verbose = TRUE,
  mt1 = FALSE
)
}
\arguments{
\item{g1_prefs}{A list of preferences of individuals who make
proposals.}

\item{g2_prefs}{A named list of preferences of individuals who receives
proposals.}

\item{g1_names}{A vector of names of the proposers. You can pass a named list
to \code{g1_prefs} instead of specifying \code{g1_names}.}

\item{g2_names}{A vector of names of the proposers. You can pass a named list
to \code{g2_prefs} instead of specifying \code{g2_names}.}

\item{algorithm}{A algorithm for matching. \code{"DA"}
(\code{"Gale-Shapley"}) or \code{"Boston"}.}

\item{switch}{A logical value. If \code{TRUE}, the roles of g1 and g2 are
switched. That is, g2 will be the proposer group, and g1 the prposed if
\code{TRUE}. Default is \code{FALSE}.}

\item{verbose}{If \code{TRUE}, matching steps will be printed on screen.
Default to \code{TRUE}.}

\item{mt1}{A logical valu. \code{TRUE} for many-to-one matching.
Default to \code{FALSE}}
}
\value{
A list of "matching" class containing
(1) a data frame of the matching results,
(2) a character string showing which algorithm was used,
(3) a character string of the matching results,
(4) a character string of the history of matching steps, and
(5) a list of preferences of each group.
}
\description{
\code{matching()} implements matching between two groups of
individuals.
}
\examples{
test1 <- matching(
  g1_prefs = list(w1 = c(1, 2),
                  w2 = c(2, 1),
                  w3 = c(1, 2)),
  g2_prefs = list(m1 = c(1, 2, 3),
                  m2 = c(2, 3, 1)))

test2 <- matching(
  g1_names = c("w1", "w2", "w3"),
  g1_prefs = list(c(1, 2),
                  c(2, 1),
                  c(1, 2)),
  g2_names = c("m1", "m2"),
  g2_prefs = list(c(1, 2, 3),
                  c(2, 3, 1)))

test3 <- matching(
  g1_names = c("Amy", "Beatrice", "Cindy"),
  g1_prefs = list(c("Dick", "Eric"),
                  c("Eric", "Dick"),
                  c("Dick", "Eric")),
  g2_names = c("Dick", "Eric"),
  g2_prefs = list(c("Amy", "Beatrice", "Cindy"),
                  c("Beatrice", "Cindy", "Amy")))

test4 <- matching(
  g1_prefs <- list(w1 = c(1, 2),
                   w2 = c(2, 1),
                   w3 = c(1, 2)),
  g2_prefs <- list(m1 = c(1, 2),
                   m2 = c(2, 3)))

\dontrun{
  ## The following function throws an error because a name (Jack) does not
  ## exist in the opponent's pool.

  test5 <- matching(
    g1_names = c("Amy", "Beatrice", "Cindy"),
    g1_prefs = list(c("Dick", "Eric"),
                    c("Eric", "Dick"),
                    c("Dick", "Jack")),
    g2_names = c("Dick", "Eric"),
    g2_prefs = list(c("Amy", "Beatrice", "Cindy"),
                    c("Beatrice", "Cindy", "Amy")))
}
}
\author{
Yoshio Kamijo and Yuki Yanai \href{mailto:yanai.yuki@kochi-tech.ac.jp}{yanai.yuki@kochi-tech.ac.jp}
}
